## 1.1. Элементы программирования

Мощный язык программирования — это нечто большее, чем просто средство, с помощью которого можно учить компьютер решать задачи. Язык также служит средой, в которой мы организуем свое мышление о процессах. Таким образом, когда мы описываем язык, мы должны уделять особое внимание тем средствам, которые в нем имеются для того, чтобы комбинировать простые понятия и получать из них сложные. Всякий язык программирования обладает тремя предназначенными для этого механизмами:

* **элементарные выражения,** представляющие минимальные сущности, с которыми язык имеет дело;
* **средства комбинирования,** с помощью которых из простых объектов составляются сложные;
* **средства абстракции,** с помощью которых сложные объекты можно называть и обращаться с ними как с единым целым.

В программировании мы имеем дело с двумя типами объектов: процедурами и данными. (Впоследствии мы обнаружим, что на самом деле большой разницы между ними нет.) Говоря неформально, данные — это «материал», который мы хотим обрабатывать, а процедуры — это описания правил обработки данных. Таким образом, от любого мощного языка программирования требуется способность описывать простые данные и элемен- тарные процедуры, а также наличие средств комбинирования и абстракции процедур и данных.

В этой главе мы будем работать только с простыми численными данными, так что мы сможем сконцентрировать внимание на правилах построения процедур. В последующих главах мы увидим, что те же самые правила позволяют нам строить процедуры для работы со сложными данными.

### 1.1.1. Выражения

Самый простой способ начать обучение программированию — рассмотреть несколько типичных примеров работы с интерпретатором JavaScript. Представьте, что Вы сидите за терминалом компьютера. Вы печатаете *выражение* (expression), а интерпретатор отвечает, выводя результат *вычисления* (evaluation) этого выражения.

Один из типов элементарных выражений, которые Вы можете вводить — это числа. (Говоря точнее, выражение, которое Вы печатаете, состоит из цифр, представляющих число по основанию 10.) Если Вы введете в  интерпретаторе JavaScript число

`486`

интерпретатор ответит Вам, напечатав

*`486`*

Выражения, представляющие числа, могут сочетаться с выражением, представляющим элементарную процедуру (скажем, + (знак плюс) или * (знак умножения)), так что получается составное выражение, представляющее собой применение процедуры к этим числам. Например:

```javascript
137 + 349;​
```
*`486`*

```javascript
1000 - 334;
```
*`666`*

```javascript
5 * 99;
```
*`495`*

```javascript
10 / 5;
```
*`2`*

```javascript
2.7 + 10;
```
*`12.7`*

Выражения такого рода, которые содержат другие выражения в качестве компонентов, называются *комбинациями* (combinations). Комбинации, образованные символом *оператора* (operator) по середине, и выражения *операнда* (operand) слева и справа от него, называются комбинациями операторов. Значение операторной комбинации вычисляется путем применения функции, задаваемой оператором, к *аргументам* (arguments), которые являются значениями операндов.


Соглашение, по которому оператор ставится между операндами, известно как *инфиксная нотация* (infix notation). С такой математической записью читатель, скорее всего, знаком со школьной скамьи и использует его в повседневной жизни. Как и в математике, комбинации операторов могут быть *вложенными* (nested), то есть они могут принимать аргументы, которые сами являются комбинациями операторов:

```javascript
(3 * 5) + (10 - 6);
```

Как обычно, круглые скобки используются для группировки операций во избежание неясностей. JavaScript также следует обычным соглашениям, когда круглые скобки опущены; Умножение и деление имеют более высокий приоритет при вычислении выражении, чем сложение и вычитание. Например,

```javascript
3 * 5 + 10 / 2;​
```

=>

```javascript
(3 * 5) + (10 / 2);​
```
Последовательности сложения и вычитания читаются слева направо, как последовательности умножений и делений. Таким образом,

```javascript
3 / 5 * 2 - 4 + 3;​
```

=>

```javascript
(((3 / 5) * 2) - 4) + 3;​
```

Операторы +, -, * и / являются левоассоциативными.

Не существует (в принципе) никакого предела для глубины такого вложения и общей сложности выражений, которые может вычислять интерпретатор JavaScript. Это мы, люди, путаемся даже в довольно простых выражениях, например

```javascript
3 * (2 * (4 + (3 - 5))) + (10 * (27 / 6))​;
```

а интерпретатор с готовностью вычисляет его и дает ответ `57`. Мы можем облегчить себе задачу, записывая такие выражения в форме

```javascript
3 * (2 * (4 + (3 - 5)))
+
(10 * (27 / 6))​
```

чтобы визуально отделить основные компоненты выражения.

Интерпретатор всегда ведет себя одинаковым образом: он считывает выражение с терминала, вычисляет его и печатает результат. Этот способ работы иногда называют *циклом чтение-вычисление-печать* (read-eval-print loop). Обратите особое внимание на то, что не нужно специально просить интерпретатор напечатать значение выражения.


### 1.1.2. Имена и окружение

Одна из важнейших характеристик языка программирования — какие в нем существуют средства использования имен для указания на вычислительные объекты. Мы говорим, что имя обозначает *константу* (constant), чьим *значением* (value) является объект.

В JavaScript мы даем вещам имена с помощью ключевого слова `const`. Предложение

```javascript
const size = 2;​
```

заставляет интерпретатор связать значение 2 с именем `size`. The purpose of evaluating the variable statement

```javascript
const size = 2;​
```

is to associate the name size with the number 2, and not to compute a value as for expression statements. Thus, the JavaScript interpreter returns the special JavaScript value `undefined` as the value of the variable statement.

После того, как имя `size` связано со значением 2, мы можем cсылаться на значение 2 с помощью имени:

```javascript
const size = 2;

size;​
```
=>

```javascript
2
```
```javascript
const size = 2;
5 * size;​
```
=>

```javascript
10
```

Note that JavaScript statements can be placed in a sequence. The interpreter evaluates the statements of the sequence in the given order, and returns the value of the last statement as the value of the sequence.

Вот еще примеры использования `const`:

```javascript
const pi = 3.14159;​
```

```javascript
const radius = 10;​
```

```javascript
const pi = 3.14159;

const radius = 10;

pi * radius * radius;​
```
=>

```javascript
314.159
```
```javascript
const pi = 3.14159;

const radius = 10;

const circumference = 2 * pi * radius;​

circumference;​
```

=>

```javascript
62.8318
```
Слово `const` служит в нашем языке простейшим средством абстракции, поскольку оно позволяет нам использовать простые имена для обозначения результатов сложных операций, как, например, вычисленная только что длина окружности — `circumference`. Вообще говоря, вычислительные объекты могут быть весьма сложными структурами, и было бы очень неудобно, если бы нам приходилось вспоминать и повторять все их детали каждый раз, когда нам захочется их использовать. На самом деле сложные программы конструируются методом построения шаг за шагом вычислительных объектов возрастающей сложности. Интерпретатор делает такое пошаговое построение программы особенно удобным, поскольку связи между именами и объектами могут создаваться последовательно по мере взаимодействия программиста с компьютером.

Ясно, что раз интерпретатор способен ассоциировать значения с символами и затем вспоминать их, то он должен иметь некоторого рода память, сохраняющую пары имя-объект. Эта память называется *окружением* (environment) (а точнее, *глобальным окружением* (global environment), поскольку позже мы увидим, что вычисление может иметь дело с несколькими окружениями).

### 1.1.3. Вычисление комбинаций

One of our goals in this chapter is to isolate issues about process descriptions. As a case in point, let us consider that, in evaluating operator combinations, the interpreter proceeds as follows.
Одна из наших целей в этой главе — выделить элементы описания процессов. Рассуждая в этом русле, примем во внимание, что интерпретатор, вычисляя значения комбинации операторов, исходит из следующего:

Чтобы вычислить комбинацию оператора, требуется:
– Вычислить все подвыражения комбинации.
-Apply the function that is denoted by the operator to the arguments that are the values of the operands.
– Применить функцию, которая обозначается оператором к аргументам — которые являются значениями операндов.

Даже в этом простом правиле видны несколько важных свойств процессов в целом. Прежде всего, заметим, что на первом шаге для того, чтобы провести процесс вычисления для комбинации, нужно сначала проделать процесс вычисления для каждого элемента комбинации. Таким образом, правило вычисления *рекурсивно* (recursive) по своей природе; это означает, что в качестве одного из своих шагов оно включает применение того же самого правила.

Заметьте, какую краткость понятие рекурсии придает описанию того, что в случае комбинации с глубоким вложением выглядело бы как достаточно сложный процесс. Например, чтобы вычислить

```javascript
(2 + 4 * 6) * (3 + 5 + 7);​
```
requires that the evaluation rule be applied to four different expressions. We can obtain a picture of this process by representing the expression in the form of a tree, as shown in Figure 1.1. Each expression is represented by a node with branches corresponding to the operator and the operands of the operator combination stemming from it. The terminal nodes (that is, nodes with no branches stemming from them) represent either operators or numbers. Viewing evaluation in terms of the tree, we can imagine that the values of the operands percolate upward, starting from the terminal nodes and then combining at higher and higher levels. In general, we shall see that recursion is a very powerful technique for dealing with hierarchical, treelike objects. In fact, the “percolate values upward” form of the evaluation rule is an example of a general kind of process known as tree accumulation.

требуется применить правило вычисления к четырем различным комбинациям. Картину этого процесса можно получить, нарисовав комбинацию в виде дерева, как показано на рис. 1.1. Каждая комбинация представляется в видевершины, а ее оператор и операн- ды — в виде ветвей, исходящих из этой вершины. Концевые вершины (то есть те, из которых не исходит ни одной ветви) представляют операторы или числа. Рассматривая вычисление как дерево, мы можем представить себе, что значения операндов распро- страняются от концевых вершин вверх и затем комбинируются на все более высоких уровнях. Впоследствии мы увидим, что рекурсия — это вообще очень мощный метод обработки иерархических, древовидных объектов. На самом деле форма правила вы- числения «распространить значения наверх» является примером общего типа процессов, известного как *накопление по дереву* (tree accumulation).

![tree-accumulation](https://github.com/sicp-js/sicp-js-ru/blob/master/images/tree-accumulation.png)
